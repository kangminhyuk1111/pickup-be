name: Spring Boot 자동 빌드 및 배포 (디버깅 버전)

on:
  push:
    branches: [ "main", "develop" ]

permissions:
  contents: read

jobs:
  spring-build:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4

      - name: JDK 17 버전 설치
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Gradle Cache 설정
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Gradle 접근 권한 설정
        run: chmod +x gradlew

      - name: Gradle 세팅
        uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582
        with:
          cache-read-only: false

      - name: 빌드 환경 변수 설정 및 JAR 파일 생성
        env:
          DB_URL: ${{ secrets.DB_URL }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          JPA_DDL_AUTO: ${{ secrets.JPA_DDL_AUTO }}
          JPA_SHOW_SQL: ${{ secrets.JPA_SHOW_SQL }}
          JPA_FORMAT_SQL: ${{ secrets.JPA_FORMAT_SQL }}
          THYMELEAF_CACHE: ${{ secrets.THYMELEAF_CACHE }}
          LOG_LEVEL: ${{ secrets.LOG_LEVEL }}
          HIBERNATE_LOG_LEVEL: ${{ secrets.HIBERNATE_LOG_LEVEL }}
          HIBERNATE_BINDING_LOG_LEVEL: ${{ secrets.HIBERNATE_BINDING_LOG_LEVEL }}
          GITHUB_CLIENT_ID: ${{ secrets.GITHUB_CLIENT_ID }}
          GITHUB_CLIENT_SECRET: ${{ secrets.GITHUB_CLIENT_SECRET }}
          GITHUB_REDIRECT_URI: ${{ secrets.GITHUB_REDIRECT_URI }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI: ${{ secrets.GOOGLE_REDIRECT_URI }}
          KAKAO_CLIENT_ID: ${{ secrets.KAKAO_CLIENT_ID }}
          KAKAO_CLIENT_SECRET: ${{ secrets.KAKAO_CLIENT_SECRET }}
          KAKAO_REDIRECT_URI: ${{ secrets.KAKAO_REDIRECT_URI }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          JWT_EXPIRE_LENGTH: ${{ secrets.JWT_EXPIRE_LENGTH }}
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
          CSRF_ENABLED: ${{ secrets.CSRF_ENABLED }}
          GRADLE_OPTS: -Xmx4g -XX:+UseParallelGC
        run: |
          ./gradlew build \
            --build-cache \
            --parallel \
            --no-daemon

      - name: 빌드된 JAR 파일 확인
        run: |
          echo "=== 빌드 완료 후 JAR 파일 확인 ==="
          find build/libs -name "*.jar" -exec ls -la {} \;
          echo "=== JAR 파일 상세 정보 ==="
          for jar in build/libs/*.jar; do
            echo "파일: $jar"
            echo "크기: $(du -h "$jar" | cut -f1)"
            echo "내용 확인:"
            jar tf "$jar" | head -10
            echo "---"
          done

      - name: EC2에 JAR 파일 업로드
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_PRIVATE_KEY }}
          source: "build/libs/*.jar"
          target: "/home/ubuntu/"
          strip_components: 2
          debug: true

      - name: EC2 서버 상태 확인 (사전 점검)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_PRIVATE_KEY }}
          timeout: 60s
          script: |
            echo "=== 🔍 EC2 서버 사전 점검 ==="
            echo "현재 시간: $(date)"
            echo "서버 정보: $(uname -a)"
            echo "메모리 사용량:"
            free -h
            echo "디스크 사용량:"
            df -h /home/ubuntu
            echo "현재 디렉토리 위치: $(pwd)"
            echo "Java 설치 확인:"
            java -version 2>&1 || echo "❌ Java가 설치되지 않음"
            echo "네트워크 연결 확인:"
            curl -s http://google.com > /dev/null && echo "✅ 인터넷 연결 정상" || echo "❌ 인터넷 연결 문제"

      - name: EC2 서버에 애플리케이션 배포 (디버깅 모드)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_PRIVATE_KEY }}
          timeout: 180s
          command_timeout: 120s
          script: |
            #!/bin/bash
            set -e  # 에러 발생시 즉시 중단
            
            echo "=== 🚀 배포 시작 (디버깅 모드) ==="
            echo "스크립트 시작 시간: $(date)"
            
            # 디렉토리 이동
            cd /home/ubuntu
            echo "✅ 현재 작업 디렉토리: $(pwd)"
            
            # 1단계: 환경 확인
            echo ""
            echo "=== 📋 1단계: 환경 확인 ==="
            echo "Java 버전:"
            java -version 2>&1 | head -3
            echo "사용자: $(whoami)"
            echo "홈 디렉토리 권한:"
            ls -la /home/ubuntu | head -5
            
            # 2단계: 기존 프로세스 확인 및 종료
            echo ""
            echo "=== 🔄 2단계: 기존 프로세스 관리 ==="
            EXISTING_JAVA_PROCESSES=$(pgrep -f "java.*jar" || echo "")
            if [ -n "$EXISTING_JAVA_PROCESSES" ]; then
                echo "기존 Java 프로세스 발견:"
                echo "$EXISTING_JAVA_PROCESSES"
                echo "프로세스 상세 정보:"
                ps aux | grep "java.*jar" | grep -v grep || echo "상세 정보 없음"
            
                # 더 안전한 방법으로 프로세스 종료
                echo "프로세스 개별 종료 시도..."
                for pid in $EXISTING_JAVA_PROCESSES; do
                    echo "PID $pid 종료 중..."
                    kill -15 $pid 2>/dev/null || echo "PID $pid 종료 실패 (이미 종료되었을 수 있음)"
                done
            
                sleep 5
                echo "종료 후 프로세스 확인:"
                REMAINING_PROCESSES=$(pgrep -f "java.*jar" || echo "")
                if [ -n "$REMAINING_PROCESSES" ]; then
                    echo "⚠️ 일부 프로세스가 여전히 실행 중: $REMAINING_PROCESSES"
                    echo "강제 종료 시도..."
                    for pid in $REMAINING_PROCESSES; do
                        kill -9 $pid 2>/dev/null || echo "PID $pid 강제 종료 실패"
                    done
                    sleep 2
                else
                    echo "✅ 모든 프로세스 종료됨"
                fi
            else
                echo "✅ 실행 중인 Java 프로세스 없음"
            fi
            
            # 3단계: 파일 시스템 확인
            echo ""
            echo "=== 📁 3단계: 파일 시스템 확인 ==="
            echo "전체 파일 목록:"
            ls -la
            echo ""
            echo "JAR 파일 상세 분석:"
            if ls *.jar 1> /dev/null 2>&1; then
                for jar in *.jar; do
                    echo "파일명: $jar"
                    echo "  크기: $(du -h "$jar" | cut -f1)"
                    echo "  수정시간: $(stat -c %y "$jar")"
                    echo "  권한: $(ls -l "$jar" | cut -d' ' -f1)"
                    echo "  소유자: $(ls -l "$jar" | cut -d' ' -f3-4)"
                    if [[ "$jar" == *"plain"* ]]; then
                        echo "  ⚠️ 이 파일은 plain.jar입니다 (의존성 미포함)"
                    else
                        echo "  ✅ 실행 가능한 JAR 파일로 추정됩니다"
                    fi
                    echo ""
                done
            else
                echo "❌ JAR 파일이 없습니다!"
                echo "업로드 실패 가능성 확인 필요"
                exit 1
            fi
            
            # 4단계: 실행할 JAR 파일 선택
            echo "=== 🎯 4단계: 실행 파일 선택 ==="
            # plain.jar 제외하고 가장 큰 파일 선택 (의존성 포함된 파일일 가능성이 높음)
            JAR_FILE=$(ls -la *.jar | grep -v "plain" | sort -k5 -nr | head -n1 | awk '{print $9}')
            
            if [ -z "$JAR_FILE" ] || [ ! -f "$JAR_FILE" ]; then
                echo "❌ 실행 가능한 JAR 파일을 찾을 수 없습니다"
                echo "사용 가능한 파일들:"
                ls -la *.jar
                exit 1
            fi
            
            echo "선택된 JAR 파일: $JAR_FILE"
            echo "파일 크기: $(du -h "$JAR_FILE" | cut -f1)"
            
            # JAR 파일 내용 간단 확인
            echo "JAR 파일 내용 미리보기:"
            jar tf "$JAR_FILE" | grep -E "(BOOT-INF|META-INF|MANIFEST)" | head -5 || echo "JAR 내용 확인 불가"
            
            # 5단계: 애플리케이션 시작
            echo ""
            echo "=== 🚀 5단계: 애플리케이션 시작 ==="
            echo "시작 시간: $(date)"
            echo "명령어: java -Xms512m -Xmx1024m -jar $JAR_FILE"
            
            # 이전 로그 백업
            if [ -f "app.log" ]; then
                mv app.log "app.log.backup.$(date +%Y%m%d_%H%M%S)"
                echo "이전 로그 파일 백업 완료"
            fi
            
            # 애플리케이션 시작
            nohup java -Xms512m -Xmx1024m -jar "$JAR_FILE" > app.log 2>&1 &
            APP_PID=$!
            echo "애플리케이션 PID: $APP_PID"
            echo $APP_PID > app.pid
            
            # 6단계: 시작 확인
            echo ""
            echo "=== ✅ 6단계: 시작 확인 ==="
            echo "10초 대기 중..."
            sleep 10
            
            # 프로세스 확인
            if kill -0 $APP_PID 2>/dev/null; then
                echo "✅ 프로세스가 실행 중입니다 (PID: $APP_PID)"
            else
                echo "❌ 프로세스가 종료되었습니다"
                echo "로그 확인:"
                cat app.log
                exit 1
            fi
            
            # 포트 확인
            echo "포트 8080 리스닝 확인:"
            if netstat -tlnp 2>/dev/null | grep :8080; then
                echo "✅ 포트 8080이 활성화되었습니다"
            else
                echo "⚠️ 포트 8080이 아직 활성화되지 않았습니다 (시작 중일 수 있음)"
            fi
            
            # 애플리케이션 로그 확인
            echo ""
            echo "=== 📄 애플리케이션 로그 (최근 20줄) ==="
            if [ -f "app.log" ]; then
                tail -20 app.log
            else
                echo "❌ app.log 파일이 생성되지 않았습니다"
            fi
            
            # 7단계: 최종 상태 요약
            echo ""
            echo "=== 📊 7단계: 배포 상태 요약 ==="
            echo "배포 완료 시간: $(date)"
            echo "실행 중인 Java 프로세스:"
            pgrep -f "java.*jar" || echo "실행 중인 프로세스 없음"
            echo "메모리 사용량:"
            free -h | head -2
            echo "디스크 사용량:"
            df -h /home/ubuntu | tail -1
            
            # 접속 테스트
            echo ""
            echo "=== 🌐 8단계: 접속 테스트 ==="
            echo "로컬호스트 접속 테스트:"
            timeout 5 curl -s http://localhost:8080 > /dev/null && echo "✅ localhost:8080 응답 정상" || echo "❌ localhost:8080 응답 없음"
            
            echo ""
            echo "🎉 배포 스크립트 완료!"
            echo "브라우저에서 http://$(curl -s ifconfig.me):8080 접속을 시도해보세요"